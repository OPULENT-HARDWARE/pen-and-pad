<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
<title>Scribble Note — Pen & Pad</title>
<link href="https://fonts.googleapis.com/css2?family=Saira+Semi+Condensed:wght@500;600&display=swap" rel="stylesheet">
<style>
  :root{
    --paper:#f4fff7; --dots:#7aa68a; --ui:#0e2b1f; --ui-muted:#5c7a6a;
    --accent:#1aa36f; --accent-2:#0d8157;
    --tear:#e9752a; --tear-pressed:#c7611f;
    --shadow:rgba(0,0,0,.25); --perforation:#d2e8db;

    --seg-bg:rgba(0,0,0,.06);
    --seg-border:rgba(0,0,0,.14);
    --seg-active:#ffffff;
    --seg-active-border:rgba(0,0,0,.18);
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%}
  body{
    min-height:100svh;background:var(--paper);color:var(--ui);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
  }
  .wrap{position:relative;width:100%;min-height:100svh;height:100%;overflow:hidden}

  /* Toolbar: edge-to-edge, wraps if needed */
  .toolbar{
    position:absolute; top:8px; left:8px; right:8px; transform:none;
    display:flex; flex-wrap:wrap; align-items:center; gap:12px;
    padding:8px 12px; background:rgba(255,255,255,.7);
    backdrop-filter:saturate(1.2) blur(6px);
    border:1px solid rgba(0,0,0,.08); border-radius:14px;
    box-shadow:0 6px 18px var(--shadow); z-index:4; user-select:none;
  }
  .toolbar.collapsed{ gap:6px; padding:6px 8px; }

  /* Title */
  .title{display:flex;flex-direction:column;line-height:1.05;margin-right:6px; white-space:nowrap}
  .title-main{font-weight:700;letter-spacing:.2px;font-size:1.05rem;color:var(--ui)}
  .title-sub{margin-top:2px;font-size:.78rem;color:var(--ui-muted)}
  .title-sub .oh{font-family:"Saira Semi Condensed",system-ui,sans-serif;text-transform:uppercase;letter-spacing:.08em;font-weight:600}
  .toolbar.collapsed .title-main{font-size:.95rem}
  .toolbar.collapsed .title-sub{font-size:.7rem}

  .btn{
    appearance:none;border:0;outline:0;cursor:pointer;
    padding:8px 12px;border-radius:12px;font-weight:600;
    transition:transform .05s ease,background .15s ease,box-shadow .15s ease;
  }
  .btn:active{transform:translateY(1px)}
  .btn.tear{background:var(--tear);color:#fff}
  .btn.tear:active{background:var(--tear-pressed)}
  .btn.secondary{background:transparent;color:var(--ui);border:1px solid rgba(0,0,0,.12)}
  .btn.secondary:hover{background:rgba(0,0,0,.04)}
  .btn.secondary:active{background:rgba(0,0,0,.08)}
  .btn.icon.only{padding:8px 10px; min-width:38px}
  .toolbar.collapsed .btn{padding:6px 10px;border-radius:10px}

  .hint{font-size:.85rem;color:var(--ui-muted);white-space:nowrap}
  .toolbar.collapsed .hint{display:none}

  /* Segmented pill: Draw | Type */
  .seg{
    display:inline-flex; border-radius:9999px; padding:3px; gap:2px;
    background:var(--seg-bg); border:1px solid var(--seg-border);
  }
  .seg button{
    border:0; background:transparent; padding:6px 12px; border-radius:9999px;
    font-weight:600; cursor:pointer;
    transition:background .15s ease, box-shadow .15s ease, transform .05s ease;
  }
  .seg button:active{ transform:translateY(1px) }
  .seg button.active{
    background:var(--seg-active); box-shadow:0 1px 0 rgba(0,0,0,.06), 0 0 0 1px var(--seg-active-border) inset;
  }

  /* Controls row */
  .controls-row{display:flex;align-items:center;gap:10px; flex-wrap:wrap}
  .control{display:flex;align-items:center;gap:8px;font-size:.9rem;white-space:nowrap}
  .select,.range,.number{
    padding:6px 8px;border-radius:10px;border:1px solid rgba(0,0,0,.12);background:rgba(255,255,255,.85)
  }
  input[type=range]{accent-color:var(--accent)}
  label{color:var(--ui-muted)}

  /* Ellipsis + Popover */
  .more{display:none}
  .toolbar.collapsed .more{display:inline-flex}
  .popover{
    position:absolute; top:100%; right:8px; margin-top:8px; z-index:5;
    min-width:280px; background:rgba(255,255,255,.9);
    border:1px solid rgba(0,0,0,.1); border-radius:12px;
    box-shadow:0 10px 24px rgba(0,0,0,.25); padding:10px;
    backdrop-filter:blur(8px); display:none;
  }
  .popover.open{display:block}
  .popover .row{display:flex;align-items:center;gap:10px; margin:8px 0; flex-wrap:wrap}
  .popover .row .control{flex:1 1 auto}
  .popover .line{height:1px;background:rgba(0,0,0,.08);margin:8px 0}

  /* Collapse chevron */
  .collapse-btn{margin-left:auto}
  .collapse-btn .chev{display:inline-block; transition:transform .18s ease}
  .toolbar.collapsed .collapse-btn .chev{transform:rotate(180deg)}

  /* Canvas layers */
  canvas#grid,canvas#ink{position:absolute;inset:0;width:100%;height:100%;touch-action:none}
  canvas#grid{z-index:0} canvas#ink{z-index:1}

  /* Perforation (visual) */
  .tear-overlay{
    pointer-events:none;position:absolute;left:0;right:0;top:58px;height:14px;z-index:2;
    background:repeating-linear-gradient(90deg,transparent 0 16px,var(--perforation) 16px 18px),
               linear-gradient(var(--perforation),var(--perforation));
    background-size:auto 2px,100% 2px;background-position:0 6px;opacity:.9;
  }
  .page{position:absolute;inset:0;background:transparent;z-index:2;transform-origin:top center;pointer-events:none}
  .page.tearing{animation:tearAway .7s ease-in forwards}
  @keyframes tearAway{
    0%{transform:translateY(0) rotate(0);filter:drop-shadow(0 12px 18px var(--shadow))}
    30%{transform:translateY(6px) rotate(-.3deg)}
    100%{transform:translateY(-110%) rotate(-2deg);opacity:0}
  }

  .badge{
    position:absolute;right:10px;bottom:10px;z-index:3;
    font-size:.75rem;color:var(--ui-muted);background:rgba(255,255,255,.5);
    border:1px solid rgba(0,0,0,.08);padding:6px 8px;border-radius:10px;backdrop-filter:blur(4px);
  }

  .status{position:fixed;left:8px;bottom:8px;width:10px;height:10px;border-radius:50%;background:#bbb;z-index:4}
  .status.ok{background:#24c768}

  /* Inline editor (contenteditable) */
  #inlineEditor{
    position:absolute; z-index:3; /* above canvas, below toolbar */
    min-width:1px; background:transparent; color:#0c1e16;
    outline:0; border:0; padding:0; margin:0;
    white-space:pre-wrap; word-break:break-word;
    -webkit-user-select:text; user-select:text;
    caret-color:#0c1e16;
    display:none;
    pointer-events:none; /* default: does not intercept input */
  }

  /* Tablet compression */
  @media (min-width:768px) and (pointer:coarse){
    .toolbar{gap:10px}
    .btn{padding:7px 10px;border-radius:10px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="toolbar" id="toolbar">
    <span class="title">
      <span class="title-main">Scribble Note</span>
      <span class="title-sub">by <span class="oh">OPULENT HARDWARE</span></span>
    </span>

    <button class="btn tear" id="tear">Tear Off</button>
    <button class="btn secondary" id="undoBtn">Undo</button>

    <!-- Segmented pill: Draw | Type -->
    <div class="seg" role="tablist" aria-label="Input mode">
      <button id="segDraw" role="tab" aria-selected="true" class="active" title="Draw mode">Draw</button>
      <button id="segType" role="tab" aria-selected="false" title="Type mode">Type</button>
    </div>

    <!-- Expanded-only advanced controls -->
    <div class="controls-row" id="controlsRow">
      <button class="btn secondary" id="clear">New Page</button>
      <div class="control">
        <label for="fontSel">Font</label>
        <select id="fontSel" class="select">
          <option value="system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif">Sans</option>
          <option value="ui-rounded,ui-script,'Segoe Print','Bradley Hand','Comic Sans MS',cursive">Cursive</option>
          <option value="ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace">Mono</option>
        </select>
      </div>
      <div class="control">
        <label for="fontSize">Size</label>
        <input id="fontSize" class="number" type="number" min="10" max="72" step="1" value="20" style="width:70px"/>
      </div>
      <div class="control">
        <label for="thick">Pen</label>
        <input id="thick" class="range" type="range" min="1" max="6" value="3" step="0.5"/>
      </div>
      <div class="control">
        <label for="smooth">Smooth</label>
        <input id="smooth" class="range" type="range" min="0" max="1" value="0.5" step="0.05"/>
      </div>
    </div>

    <!-- Collapsed-only: more (popover) -->
    <button class="btn secondary icon only more" id="moreBtn" aria-haspopup="true" aria-expanded="false" title="More">⋯</button>

    <!-- Collapse chevron -->
    <button class="btn secondary icon only collapse-btn" id="collapseBtn" aria-expanded="false" title="Collapse/Expand toolbar">
      <span class="chev">▲</span>
    </button>

    <span class="hint">Default draw • Toggle Type to enter typing • Undo reverses last • <b>Tear Off saves your note</b></span>

    <!-- Popover for advanced controls (collapsed mode) -->
    <div class="popover" id="popover" role="dialog" aria-label="More controls">
      <div class="row">
        <button class="btn secondary" id="clear2" style="width:100%">New Page</button>
      </div>
      <div class="line"></div>
      <div class="row">
        <div class="control" style="flex:1">
          <label for="fontSel2">Font</label>
          <select id="fontSel2" class="select" style="width:100%">
            <option value="system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif">Sans</option>
            <option value="ui-rounded,ui-script,'Segoe Print','Bradley Hand','Comic Sans MS',cursive">Cursive</option>
            <option value="ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace">Mono</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div class="control"><label for="fontSize2">Size</label><input id="fontSize2" class="number" type="number" min="10" max="72" step="1" value="20" style="width:80px"/></div>
        <div class="control" style="min-width:140px"><label for="thick2">Pen</label><input id="thick2" class="range" type="range" min="1" max="6" value="3" step="0.5"/></div>
      </div>
      <div class="row">
        <div class="control" style="min-width:140px"><label for="smooth2">Smooth</label><input id="smooth2" class="range" type="range" min="0" max="1" value="0.5" step="0.05"/></div>
      </div>
    </div>
  </div>

  <div class="tear-overlay"></div>
  <div class="page" id="pageAnim"></div>

  <canvas id="grid"></canvas>
  <canvas id="ink"></canvas>
  <div class="badge">Dotted engineering paper • ink + typed text</div>

  <!-- Floating inline editor -->
  <div id="inlineEditor" contenteditable="true" spellcheck="true"></div>
</div>
<div id="status" class="status"></div>

<script>
(()=>{
  /* ================= Core setup ================= */
  const toolbar = document.getElementById('toolbar');
  const grid=document.getElementById("grid"), ink=document.getElementById("ink");
  const gtx=grid.getContext("2d"), ctx=ink.getContext("2d");
  ctx.lineCap="round"; ctx.lineJoin="round";

  const ui={
    tear:document.getElementById("tear"),
    clear:document.getElementById("clear"),
    clear2:document.getElementById("clear2"),
    undoBtn:document.getElementById("undoBtn"),
    segDraw:document.getElementById("segDraw"),
    segType:document.getElementById("segType"),
    thick:document.getElementById("thick"),
    smooth:document.getElementById("smooth"),
    fontSel:document.getElementById("fontSel"),
    fontSize:document.getElementById("fontSize"),
    thick2:document.getElementById("thick2"),
    smooth2:document.getElementById("smooth2"),
    fontSel2:document.getElementById("fontSel2"),
    fontSize2:document.getElementById("fontSize2"),
    pageAnim:document.getElementById("pageAnim"),
    moreBtn:document.getElementById("moreBtn"),
    popover:document.getElementById("popover"),
    collapseBtn:document.getElementById("collapseBtn"),
    controlsRow:document.getElementById("controlsRow"),
    inlineEditor:document.getElementById("inlineEditor")
  };

  function getDPR(){ return Math.max(1, window.devicePixelRatio || 1); }
  let dpr = getDPR();

  /* ============== Stability guards (keyboard / viewport) ============== */
  let suspendResize=false, keyboardLock=false, ignoreResizeUntil=0, resizeTimer=null;
  const DEBOUNCE_MS=180, MICRO_GUARD_MS=250;
  const now=()=>performance.now();

  function debouncedResizeAll(){
    if (suspendResize || keyboardLock || now()<ignoreResizeUntil) return;
    clearTimeout(resizeTimer);
    resizeTimer=setTimeout(resizeAll, DEBOUNCE_MS);
  }
  function sizeCanvas(c){
    const r=c.getBoundingClientRect();
    let w=Math.round(r.width*dpr), h=Math.round(r.height*dpr);
    if (w<2 || h<2){ w=Math.round(innerWidth*dpr); h=Math.round(innerHeight*dpr); }
    c.width=w; c.height=h;
  }
  function resizeAll(){
    if (suspendResize || keyboardLock || now()<ignoreResizeUntil) return;
    dpr=getDPR();
    sizeCanvas(grid); sizeCanvas(ink);
    drawGrid(); redraw();
  }

  if (window.visualViewport){
    let lastVVH = window.visualViewport.height;
    window.visualViewport.addEventListener('resize', ()=>{
      const vvh=window.visualViewport.height, delta=lastVVH - vvh;
      if (delta>60) keyboardLock=true;
      if (vvh>=lastVVH-10){ keyboardLock=false; debouncedResizeAll(); }
      lastVVH=vvh;
    }, {passive:true});
  }

  if (document.fonts && document.fonts.ready){
    document.fonts.ready.then(()=>{ redraw(); });
    document.fonts.addEventListener?.('loadingdone', ()=>{ redraw(); });
  }
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible'){ debouncedResizeAll(); redraw(); } });
  window.addEventListener('pageshow', ()=>{ debouncedResizeAll(); redraw(); });
  window.addEventListener('orientationchange', ()=>{ debouncedResizeAll(); });

  window.addEventListener('resize', debouncedResizeAll, {passive:true});
  window.addEventListener('load', ()=>{ requestAnimationFrame(()=>{ resizeAll(); requestAnimationFrame(resizeAll); }); });
  new ResizeObserver(()=> debouncedResizeAll()).observe(document.body);

  /* ================= Grid ================= */
  function drawGrid(){
    const {width:w,height:h}=grid;
    gtx.clearRect(0,0,w,h);
    gtx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue("--paper")||"#f4fff7";
    gtx.fillRect(0,0,w,h);
    const gap=20*dpr, r=.85*dpr;
    gtx.fillStyle="rgba(122,166,138,.65)";
    for(let y=gap/2;y<h;y+=gap){
      for(let x=gap/2;x<w;x+=gap){
        gtx.beginPath(); gtx.arc(x,y,r,0,Math.PI*2); gtx.fill();
      }
    }
  }

  /* ================= State ================= */
  let strokes=[], texts=[], history=[];
  let isDrawing=false, current=null;
  let typeMode=false; // default draw
  let typing=false, activeText=null;

  /* ================= Autosave / Restore ================= */
  const SAVE_KEY='pad.state.v1';
  let saveTimer=null, dirty=false;
  function serialize(){
    const rs=(n)=>Math.round(n*100)/100;
    return JSON.stringify({
      strokes: strokes.map(s=>({
        base:s.base, smooth:s.smooth, color:s.color,
        points: s.points.map(p=>({x:rs(p.x),y:rs(p.y),t:rs(p.t),p:rs(p.p)}))
      })),
      texts: texts.map(t=>({
        x:rs(t.x), y:rs(t.y), lines:[...t.lines], font:t.font||"", size:t.size|0
      }))
    });
  }
  function deserialize(json){
    try{
      const obj=JSON.parse(json);
      if(!obj || !Array.isArray(obj.strokes) || !Array.isArray(obj.texts)) return false;
      strokes = obj.strokes.map(s=>({
        base:+s.base||3, smooth:+s.smooth||0.5, color:s.color||"#0c1e16",
        points: Array.isArray(s.points)? s.points.map(p=>({x:+p.x,y:+p.y,t:+p.t,p:+p.p||.3})) : []
      }));
      texts = obj.texts.map(t=>({
        x:+t.x||0, y:+t.y||0, lines:Array.isArray(t.lines)? t.lines.map(String) : [""],
        font:String(t.font||""), size:+t.size||20
      }));
      history=[]; current=null; activeText=null; typing=false;
      redraw();
      return true;
    }catch(_){ return false; }
  }
  function scheduleSave(){
    dirty=true;
    clearTimeout(saveTimer);
    saveTimer=setTimeout(()=>{ if(dirty){ localStorage.setItem(SAVE_KEY, serialize()); dirty=false; } }, 600);
  }
  function hardSave(){ localStorage.setItem(SAVE_KEY, serialize()); dirty=false; }
  window.addEventListener('beforeunload', hardSave);
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState!=='visible') hardSave(); });
  (function tryRestore(){ const data=localStorage.getItem(SAVE_KEY); if(data) deserialize(data); })();

  /* ================= Coords & pen ================= */
  function toCanvasCoords(e){
    const r=ink.getBoundingClientRect();
    const x=(e.clientX-r.left)*dpr, y=(e.clientY-r.top)*dpr;
    const p=(typeof e.pressure==="number" && e.pressure>0)? e.pressure : .3;
    return {x,y,p,t:performance.now()};
  }
  function strokeWidth(i,pts,base){
    const p=pts[i], prev=pts[i-1]||p;
    const dx=p.x-prev.x, dy=p.y-prev.y, dt=Math.max(.1,(p.t-prev.t));
    const v=Math.hypot(dx,dy)/dt, min=.6,max=2.2, pressure=(p.p>.05)?(.5+p.p*.9):1;
    return base*(min+(max-min)*(1/(1+v*14)))*pressure;
  }
  function drawPath(pts,color,base,smooth){
    if(pts.length<2) return;
    ctx.save(); ctx.strokeStyle=color; ctx.beginPath();
    const L=(a,b,t)=>a+(b-a)*t, mid=(a,b,s)=>({x:L(a.x,b.x,s),y:L(a.y,b.y,s),p:L(a.p,b.p,s),t:L(a.t,b.t,s)});
    let p0=pts[0]; ctx.moveTo(p0.x,p0.y);
    for(let i=1;i<pts.length;i++){
      const p1=pts[i], m=mid(p0,p1,.5+(smooth-.5)*.6);
      ctx.lineWidth=strokeWidth(i,pts,base*dpr);
      ctx.quadraticCurveTo(p0.x,p0.y,m.x,m.y);
      p0=p1;
    }
    ctx.stroke(); ctx.restore();
  }

  /* ================= Text drawing ================= */
  function setCanvasFont(font,sizePx){
    const DEF="system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif";
    const stack=(typeof font==="string" && font.trim().length)? font : DEF;
    const px=Math.max(8, sizePx|0);
    ctx.font=`${px*dpr}px ${stack}`;
    ctx.textBaseline="alphabetic";
    ctx.fillStyle="#0c1e16";
  }
  function drawTextObject(t){
    if(!t || !Array.isArray(t.lines)) return;
    if(t.lines.length===0) t.lines=[""];
    setCanvasFont(t.font,t.size);
    const lh=Math.round(t.size*1.35)*dpr;
    let y=t.y;
    for(const line of t.lines){ ctx.fillText(line,t.x,y); y+=lh; }
  }
  function textAtPoint(x,y){
    for(let i=texts.length-1;i>=0;i--){
      const t=texts[i];
      setCanvasFont(t.font,t.size);
      const lh=Math.round(t.size*1.35)*dpr;
      const w=Math.max(...t.lines.map(l=>ctx.measureText(l).width), 20*dpr);
      const h=Math.max(lh*t.lines.length, lh);
      const L=t.x-4*dpr, T=t.y-(t.size*1.05*dpr);
      if(x>=L && x<=L+w+8*dpr && y>=T && y<=T+h+6*dpr) return {t,i};
    }
    return null;
  }

  /* ================= Inline editor (contenteditable) ================= */
  function setEditorStyleFor(t){
    const r=ink.getBoundingClientRect();
    const cssX = r.left + (t.x / dpr);
    const cssY = r.top  + (t.y / dpr) - (t.size * 1.05);
    const lineH = Math.round(t.size*1.35);
    const fontStack = (t.font && t.font.trim().length) ? t.font : "system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif";
    const ed = ui.inlineEditor;
    ed.style.left = cssX + "px";
    ed.style.top  = cssY + "px";
    ed.style.fontFamily = fontStack;
    ed.style.fontSize   = t.size + "px";
    ed.style.lineHeight = lineH + "px";
  }
  function showEditorFor(t){
    setEditorStyleFor(t);
    const ed = ui.inlineEditor;
    ed.textContent = t.lines.join("\n");
    ed.style.display = "block";
    ed.style.pointerEvents = "auto"; // only intercept while visible
    requestAnimationFrame(()=>{ ed.focus(); placeCaretAtEnd(ed); });
  }
  function hideEditor(){
    const ed = ui.inlineEditor;
    ed.style.display = "none";
    ed.style.pointerEvents = "none"; // stop intercepting input
    ed.blur();
    ed.textContent = "";
  }
  function placeCaretAtEnd(el){
    try{
      const sel = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(el);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
    }catch(_){}
  }
  function updateActiveTextFromEditor(){
    if(!activeText) return;
    const ed = ui.inlineEditor;
    const lines = ed.textContent.replace(/\r/g,'').split("\n");
    activeText.lines = lines;
    redraw();
    scheduleSave();
  }

  /* ================= Typing interactions (with inline editor) ================= */
  function startTypingAt(e){
    const {x,y}=toCanvasCoords(e);
    const hit=textAtPoint(x,y);
    if (document.activeElement && document.activeElement !== ui.inlineEditor) {
      document.activeElement.blur?.();
    }
    if(hit){
      activeText = hit.t; typing=true; showEditorFor(activeText);
    }else{
      const t={
        x, y, lines:[""],
        font:(ui.fontSel.value||ui.fontSel2.value||""),
        size:parseInt(ui.fontSize.value||ui.fontSize2.value,10)||20
      };
      texts.push(t); history.push({type:"text"}); scheduleSave();
      activeText=t; typing=true; showEditorFor(activeText);
    }
    redraw();
  }

  // Keep editor aligned on scroll / resize (minor guard)
  window.addEventListener('scroll', ()=>{ if(typing && activeText) setEditorStyleFor(activeText); }, {passive:true});

  /* ================= Redraw (skips live-edited block to avoid double render) ================= */
  function redraw(){
    ctx.clearRect(0,0,ink.width,ink.height);
    for(const s of strokes) drawPath(s.points,s.color,s.base,s.smooth);
    if(current) drawPath(current.points,current.color,current.base,current.smooth);
    for(const t of texts){
      if(typing && activeText && t===activeText && ui.inlineEditor.style.display==='block') continue;
      drawTextObject(t);
    }
  }

  /* ================= Mode toggle (segmented) ================= */
  function updateSegUI(){
    if(typeMode){
      ui.segType.classList.add('active'); ui.segType.setAttribute('aria-selected','true');
      ui.segDraw.classList.remove('active'); ui.segDraw.setAttribute('aria-selected','false');
    }else{
      ui.segDraw.classList.add('active'); ui.segDraw.setAttribute('aria-selected','true');
      ui.segType.classList.remove('active'); ui.segType.setAttribute('aria-selected','false');
    }
  }
  function setTypeMode(on){
    ignoreResizeUntil = now() + MICRO_GUARD_MS;
    typeMode=on; updateSegUI();
    if (document.activeElement && document.activeElement !== ui.inlineEditor) {
      document.activeElement.blur?.();
    }
    suspendResize=on;
    if(!on){
      if(typing && activeText){ updateActiveTextFromEditor(); }
      typing=false; hideEditor(); activeText=null;
      redraw(); debouncedResizeAll();
    }
  }
  ui.segDraw.addEventListener('click', ()=> setTypeMode(false));
  ui.segType.addEventListener('click', ()=> setTypeMode(true));

  /* ================= DRAW interactions (non-passive + preventDefault) ================= */
  function startStroke(e){
    e.preventDefault();
    // Safety: if editor is visible, commit & hide before drawing
    if (ui.inlineEditor.style.display==='block'){
      if(typing && activeText){ updateActiveTextFromEditor(); }
      typing=false; hideEditor(); activeText=null;
    }
    isDrawing=true;
    current={points:[],color:"#0c1e16",base:parseFloat(ui.thick.value||ui.thick2.value),smooth:parseFloat(ui.smooth.value||ui.smooth2.value)};
    current.points.push(toCanvasCoords(e));
  }
  function extendStroke(e){
    if(!isDrawing||!current) return;
    e.preventDefault();
    current.points.push(toCanvasCoords(e)); redraw();
  }
  function endStroke(e){
    if(!isDrawing||!current) return;
    e && e.preventDefault();
    strokes.push(current); history.push({type:"stroke"}); current=null; isDrawing=false; redraw(); scheduleSave();
  }

  /* ================= Buttons ================= */
  function doUndo(){
    const last=history.pop();
    if(last){ if(last.type==="stroke") strokes.pop(); else if(last.type==="text") texts.pop(); redraw(); scheduleSave(); }
  }
  ui.undoBtn.addEventListener("click", doUndo);

  function newPage(){
    strokes=[]; texts=[]; history=[]; current=null;
    typing=false; activeText=null; hideEditor();
    redraw(); flashPerforation(); scheduleSave();
  }
  ui.clear?.addEventListener("click", newPage);
  ui.clear2?.addEventListener("click", ()=>{ newPage(); closePopover(); });

  // Sync duplicate controls
  function syncFont(from, to){ to.value = from.value; if(activeText){ activeText.font = to.value || ""; setEditorStyleFor(activeText); redraw(); scheduleSave(); } }
  function syncSize(from, to){ to.value = from.value; if(activeText){ activeText.size = Math.max(8, parseInt(to.value,10)||20); setEditorStyleFor(activeText); redraw(); scheduleSave(); } }
  function syncRange(from, to, key){ to.value = from.value; if(current) current[key] = parseFloat(to.value); }

  ui.fontSel.addEventListener("change", ()=> syncFont(ui.fontSel, ui.fontSel2));
  ui.fontSel2.addEventListener("change", ()=>{ syncFont(ui.fontSel2, ui.fontSel); closePopover(); });

  ui.fontSize.addEventListener("input", ()=> syncSize(ui.fontSize, ui.fontSize2));
  ui.fontSize2.addEventListener("input", ()=>{ syncSize(ui.fontSize2, ui.fontSize); });

  ui.thick.addEventListener("input", ()=> syncRange(ui.thick, ui.thick2, 'base'));
  ui.thick2.addEventListener("input", ()=>{ syncRange(ui.thick2, ui.thick, 'base'); });

  ui.smooth.addEventListener("input", ()=> syncRange(ui.smooth, ui.smooth2, 'smooth'));
  ui.smooth2.addEventListener("input", ()=>{ syncRange(ui.smooth2, ui.smooth, 'smooth'); });

  /* ================= Toolbar: collapse / popover ================= */
  function setCollapsed(v){
    toolbar.classList.toggle('collapsed', v);
    ui.controlsRow.style.display = v ? 'none' : 'flex';
    ui.moreBtn.style.display = v ? 'inline-flex' : 'none';
    ui.collapseBtn.setAttribute('aria-expanded', (!v).toString());
    localStorage.setItem('pad.collapsed', v ? '1' : '0');
    closePopover();
  }
  function closePopover(){
    ui.popover.classList.remove('open');
    ui.moreBtn.setAttribute('aria-expanded','false');
  }
  ui.moreBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    const open = !ui.popover.classList.contains('open');
    if(open){
      ui.popover.classList.add('open');
      ui.moreBtn.setAttribute('aria-expanded','true');
      ui.popover.style.right = '8px';
    }else{
      closePopover();
    }
  });
  document.addEventListener('click', (e)=>{
    if (!ui.popover.contains(e.target) && e.target !== ui.moreBtn) closePopover();
  });
  ui.collapseBtn.addEventListener('click', ()=>{
    ignoreResizeUntil = now() + MICRO_GUARD_MS;
    const collapsed = toolbar.classList.contains('collapsed');
    setCollapsed(!collapsed);
  });
  (function initCollapsed(){
    const saved = localStorage.getItem('pad.collapsed');
    const preferCollapsed = saved != null ? saved === '1'
      : (matchMedia('(pointer:coarse) and (min-width:768px)').matches);
    setCollapsed(preferCollapsed);
  })();

  /* ================= Pointer routing (non-passive) ================= */
  // Draw mode: start/extend/end strokes
  ink.addEventListener("pointerdown", e=>{
    ink.setPointerCapture(e.pointerId);
    if (typeMode){ // In type mode, a tap places/edits text
      startTypingAt(e);
      return; // do not prevent default here; editor needs focus behavior
    }
    startStroke(e);
  }, {passive:false});

  ink.addEventListener("pointermove", e=>{
    if (typeMode) return;
    extendStroke(e);
  }, {passive:false});

  ink.addEventListener("pointerup", e=>{
    if (typeMode) return;
    ink.releasePointerCapture(e.pointerId);
    endStroke(e);
  }, {passive:false});

  ink.addEventListener("pointercancel", e=>{
    if (typeMode) return;
    endStroke(e);
  }, {passive:false});

  /* ================= Keyboard ================= */
  window.addEventListener("keydown",e=>{
    if(e.key==="Escape" && typeMode){ setTypeMode(false); }
  });

  /* ================= Perforation flash & Tear Off ================= */
  function flashPerforation(){
    const el = document.getElementById('pageAnim');
    el.classList.remove("tearing"); void el.offsetWidth; el.classList.add("tearing");
    setTimeout(()=> el.classList.remove("tearing"), 800);
  }
  ui.tear.addEventListener("click",()=>{
    if(typing && activeText){ updateActiveTextFromEditor(); hideEditor(); typing=false; }
    const off=document.createElement("canvas");
    off.width=grid.width; off.height=grid.height;
    const otx=off.getContext("2d");
    otx.drawImage(grid,0,0); otx.drawImage(ink,0,0);
    const ts=new Date(), pad=n=>String(n).padStart(2,"0");
    const name=`scribble_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.png`;
    off.toBlob(blob=>{
      const a=document.createElement("a");
      a.download=name; a.href=URL.createObjectURL(blob);
      document.body.appendChild(a); a.click();
      URL.revokeObjectURL(a.href); a.remove();
    },"image/png");
    flashPerforation();
    setTimeout(()=>{ strokes=[]; texts=[]; history=[]; current=null; activeText=null; typing=false; redraw(); scheduleSave(); }, 380);
  });

  /* ================= Init ================= */
  function initialControlSync(){
    const fs=ui.fontSel.value; ui.fontSel2.value = fs;
    ui.fontSize2.value = ui.fontSize.value;
    ui.thick2.value = ui.thick.value;
    ui.smooth2.value = ui.smooth.value;
  }
  initialControlSync();
  updateSegUI();       // pill reflects default Draw
  resizeAll();         // layout & grid
})();
</script>
</body>
</html>
