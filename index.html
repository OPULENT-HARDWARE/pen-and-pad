<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scribble Note — Dotted Engineering Pad</title>
  <style>
    :root{
      --paper:#f4fff7;          /* light engineering pad tint */
      --dots:#7aa68a;           /* dot color */
      --ui:#0e2b1f;             /* UI text */
      --ui-muted:#5c7a6a;       /* subtle UI */
      --accent:#1aa36f;         /* buttons */
      --accent-2:#0d8157;
      --shadow:rgba(0,0,0,.25);
      --perforation:#d2e8db;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--paper);color:var(--ui);font-family:system-ui,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif}
    .wrap{
      position:relative;
      height:100%;
      width:100%;
      overflow:hidden;
    }

    /* Top toolbar */
    .toolbar{
      position:absolute;
      top:12px; left:50%;
      transform:translateX(-50%);
      display:flex; gap:10px; align-items:center;
      padding:8px 12px;
      background:rgba(255,255,255,.7);
      backdrop-filter:saturate(1.2) blur(6px);
      border:1px solid rgba(0,0,0,.08);
      border-radius:14px;
      box-shadow:0 6px 18px var(--shadow);
      z-index:3;
      user-select:none;
    }
    .toolbar .title{
      font-weight:600; letter-spacing:.2px; margin-right:8px; color:var(--ui);
    }
    .btn{
      appearance:none; border:0; outline:0; cursor:pointer;
      padding:8px 12px; border-radius:12px;
      background:var(--accent); color:white; font-weight:600;
      transition:transform .05s ease, background .15s ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.secondary{ background:transparent; color:var(--ui); border:1px solid rgba(0,0,0,.12) }
    .btn:hover{ background:var(--accent-2) }

    .hint{ font-size:.85rem; color:var(--ui-muted); padding-left:6px }

    /* The canvas stack */
    canvas#grid, canvas#ink{
      position:absolute; inset:0; width:100%; height:100%;
      touch-action:none; /* enable drawing on touch */
    }
    canvas#grid{ z-index:0 }
    canvas#ink{ z-index:1 }

    /* Perforation & tear animation overlay */
    .tear-overlay{
      pointer-events:none;
      position:absolute; left:0; right:0; top:58px; height:14px; z-index:2;
      background:
        repeating-linear-gradient(90deg, transparent 0 16px, var(--perforation) 16px 18px),
        linear-gradient(var(--perforation), var(--perforation));
      background-size:auto 2px, 100% 2px;
      background-repeat:no-repeat;
      background-position:0 6px, 0 6px;
      opacity:.9;
    }

    .page{
      position:absolute; inset:0; background:transparent; z-index:2;
      transform-origin: top center;
      pointer-events:none;
    }
    .page.tearing{
      animation:tearAway .7s ease-in forwards;
    }
    @keyframes tearAway{
      0% { transform:translateY(0) rotate(0); filter:drop-shadow(0 12px 18px var(--shadow)); }
      30%{ transform:translateY(6px) rotate(-0.3deg) }
      100%{ transform:translateY(-110%) rotate(-2deg); opacity:0 }
    }

    /* Small footer badge (optional) */
    .badge{
      position:absolute; right:10px; bottom:10px; z-index:3;
      font-size:.75rem; color:var(--ui-muted); background:rgba(255,255,255,.5);
      border:1px solid rgba(0,0,0,.08); padding:6px 8px; border-radius:10px;
      backdrop-filter:blur(4px);
    }

    /* Range control styling */
    .control{
      display:flex; align-items:center; gap:8px; font-size:.9rem; color:var(--ui);
      padding:0 6px;
    }
    input[type="range"]{ accent-color:var(--accent) }
    label{ color:var(--ui-muted) }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="toolbar">
      <span class="title">Scribble Note</span>
      <button class="btn" id="tear">Tear Off</button>
      <button class="btn secondary" id="clear">New Page</button>
      <div class="control">
        <label for="thick">Pen</label>
        <input id="thick" type="range" min="1" max="6" value="3" step="0.5" />
      </div>
      <div class="control">
        <label for="smooth">Smooth</label>
        <input id="smooth" type="range" min="0" max="1" value="0.5" step="0.05" />
      </div>
      <span class="hint">Draw with mouse, pen, or touch. Press <b>U</b> to undo.</span>
    </div>

    <div class="tear-overlay" aria-hidden="true"></div>
    <div class="page" id="pageAnim" aria-hidden="true"></div>

    <canvas id="grid"></canvas>
    <canvas id="ink"></canvas>

    <div class="badge">Dotted engineering paper • pressure & smoothing</div>
  </div>

  <script>
  (()=>{

    /* ---------- Canvas & DPI setup ---------- */
    const grid = document.getElementById('grid');
    const ink = document.getElementById('ink');
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    function sizeCanvas(c){
      const rect = c.getBoundingClientRect();
      c.width = Math.round(rect.width * dpr);
      c.height = Math.round(rect.height * dpr);
    }
    function resizeAll(){
      sizeCanvas(grid); sizeCanvas(ink);
      drawGrid();
      redrawAllStrokes();
    }
    window.addEventListener('resize', resizeAll, {passive:true});

    /* ---------- Dotted engineering paper ---------- */
    const gtx = grid.getContext('2d');
    function drawGrid(){
      const {width:w,height:h} = grid;
      gtx.clearRect(0,0,w,h);
      gtx.save();
      gtx.fillStyle = getComputedStyle(document.documentElement)
                      .getPropertyValue('--paper') || '#f4fff7';
      gtx.fillRect(0,0,w,h);

      // Dot pattern: every 20 CSS px, radius scaled to DPR
      const gap = 20 * dpr;
      const r = 0.85 * dpr; // dot radius
      gtx.fillStyle = 'rgba(122,166,138,.65)'; // --dots
      for(let y=gap/2; y<h; y+=gap){
        for(let x=gap/2; x<w; x+=gap){
          gtx.beginPath();
          gtx.arc(x,y,r,0,Math.PI*2);
          gtx.fill();
        }
      }
      gtx.restore();
    }

    /* ---------- Drawing engine with smoothing ---------- */
    const ctx = ink.getContext('2d');
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    let strokes = [];            // array of { points:[{x,y,t,p}], color, base, smooth }
    let current = null;
    let isDrawing = false;

    const ui = {
      tear: document.getElementById('tear'),
      clear: document.getElementById('clear'),
      thick: document.getElementById('thick'),
      smooth: document.getElementById('smooth'),
      pageAnim: document.getElementById('pageAnim')
    };

    function toCanvasCoords(evt, target=ink){
      const rect = target.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * dpr;
      const y = (evt.clientY - rect.top) * dpr;
      // pressure: if stylus reports, else derive light pressure for mouse
      const p = typeof evt.pressure === 'number' && evt.pressure>0 ? evt.pressure : 0.3;
      return {x,y,p,t:performance.now()};
    }

    function startStroke(evt){
      isDrawing = true;
      current = {
        points: [],
        color: '#0c1e16',
        base: parseFloat(ui.thick.value),      // base thickness (CSS px)
        smooth: parseFloat(ui.smooth.value)    // 0..1 smoothing factor
      };
      current.points.push(toCanvasCoords(evt));
    }
    function extendStroke(evt){
      if(!isDrawing || !current) return;
      current.points.push(toCanvasCoords(evt));
      drawLive(current);
    }
    function endStroke(){
      if(!isDrawing || !current) return;
      strokes.push(current);
      current = null;
      isDrawing = false;
    }

    // Velocity-based width modulation (if no pressure), with easing
    function strokeWidth(i, pts, base){
      const p = pts[i];
      const prev = pts[i-1] || p;
      const dx = p.x - prev.x, dy = p.y - prev.y;
      const dt = Math.max(0.1, (p.t - prev.t));
      const v = Math.hypot(dx,dy) / dt;     // px/ms
      // Map velocity to width: faster -> thinner
      const min = 0.6, max = 2.2;
      const width = base * (min + (max-min) * (1/(1+v*14)));
      // Respect pressure if present (>0.05)
      const pressureBoost = (p.p>0.05) ? (0.5 + p.p*0.9) : 1;
      return width * pressureBoost;
    }

    // Simple path smoothing using quadratic mid-point technique + blend
    function drawPath(pts, color, base, smooth){
      if(pts.length<2) return;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.beginPath();

      const lerp = (a,b,t)=>a+(b-a)*t;
      const mpt = (a,b,s)=>({x:lerp(a.x,b.x,s), y:lerp(a.y,b.y,s), p:lerp(a.p,b.p,s), t:lerp(a.t,b.t,s)});

      let p0 = pts[0];
      ctx.moveTo(p0.x, p0.y);

      for(let i=1;i<pts.length;i++){
        const p1 = pts[i];
        const mid = mpt(p0,p1, 0.5 + (smooth-0.5)*0.6); // bias smoothing
        ctx.lineWidth = strokeWidth(i, pts, base*dpr);
        ctx.quadraticCurveTo(p0.x, p0.y, mid.x, mid.y);
        p0 = p1;
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawLive(stroke){
      // Redraw only the tail for performance, but to keep it crisp we can redraw entire layer
      redrawAllStrokes();
    }

    function redrawAllStrokes(){
      ctx.clearRect(0,0,ink.width,ink.height);
      for(const s of strokes){
        drawPath(s.points, s.color, s.base, s.smooth);
      }
      if(current) drawPath(current.points, current.color, current.base, current.smooth);
    }

    /* ---------- Pointer events ---------- */
    ink.addEventListener('pointerdown', (e)=>{ ink.setPointerCapture(e.pointerId); startStroke(e); });
    ink.addEventListener('pointermove', extendStroke);
    ink.addEventListener('pointerup', (e)=>{ ink.releasePointerCapture(e.pointerId); endStroke(); });
    ink.addEventListener('pointercancel', endStroke);
    ink.addEventListener('pointerleave', ()=>{ if(isDrawing) endStroke(); });

    /* ---------- Undo (U key) ---------- */
    window.addEventListener('keydown', (e)=>{
      if(e.key.toLowerCase()==='u'){
        strokes.pop();
        redrawAllStrokes();
      }
    });

    /* ---------- Controls ---------- */
    ui.thick.addEventListener('input', ()=>{
      if(current) current.base = parseFloat(ui.thick.value);
    });
    ui.smooth.addEventListener('input', ()=>{
      if(current) current.smooth = parseFloat(ui.smooth.value);
    });

    /* ---------- New Page (no save) ---------- */
    ui.clear.addEventListener('click', ()=>{
      strokes = [];
      redrawAllStrokes();
      flashPerforation();
    });

    function flashPerforation(){
      ui.pageAnim.classList.remove('tearing');
      // quick nudge to restart animation if needed
      void ui.pageAnim.offsetWidth;
      ui.pageAnim.classList.add('tearing');
      setTimeout(()=> ui.pageAnim.classList.remove('tearing'), 800);
    }

    /* ---------- Tear Off (download + animate + reset) ---------- */
    ui.tear.addEventListener('click', async ()=>{
      // Compose grid + ink to a single image for download
      const off = document.createElement('canvas');
      off.width = grid.width; off.height = grid.height;
      const otx = off.getContext('2d');
      otx.drawImage(grid,0,0);
      otx.drawImage(ink,0,0);

      // Download
      const ts = new Date();
      const pad = n=>String(n).padStart(2,'0');
      const name = `scribble_${ts.getFullYear()}-${pad(ts.getMonth()+1)}-${pad(ts.getDate())}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(ts.getSeconds())}.png`;
      off.toBlob((blob)=>{
        const a = document.createElement('a');
        a.download = name;
        a.href = URL.createObjectURL(blob);
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
      }, 'image/png');

      // Animate tear & clear
      flashPerforation();
      setTimeout(()=>{
        strokes = [];
        redrawAllStrokes();
      }, 380);
    });

    /* ---------- Initialize ---------- */
    resizeAll();

  })();
  </script>
</body>
</html>
